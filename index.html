<!DOCTYPE HTML> 
<html>
<head>
<meta charset="UTF-8">

<title>Insert title here</title>
<script src="lib/Healpix/Xyf.js"></script>
<script src="lib/Healpix/Vec3.js"></script>
<script src="lib/Healpix/Hploc.js"></script>
<script src="lib/Healpix/Fxyf.js"></script>
<script src="lib/Healpix/Healpix.js"></script> 

<script src="lib/utils/webgl-debug.js"></script>

<script src="lib/glMatrix/glMatrix.js"></script>

<script id="shader-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec4 aVertexColor;
  
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
  
	varying vec4 vColor;
  
	void main() {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vColor = aVertexColor;
	}
</script>

<script id="shader-fs" type="x-shader/x-fragment">
  precision mediump float;
  
  varying vec4 vColor;
  void main() {
    gl_FragColor = vColor;   
  } 
</script>

<script type="text/javascript">

var norder = 3;
var nside = Math.pow(2, norder);
var healpix = new Healpix(nside);
var maxNPix = healpix.getNPix();

var vertexIndexBuffer;
var vertexPositionBuffer;

var gl;
var canvas;
var shaderProgram;

var modelViewMatrix;
var projectionMatrix;
var modelViewMatrixStack;

var pwgl = {};

function initWebGL(canvas) {
    gl = null;
    
    try {
        // Try to grab the standard context. If it fails, fallback to experimental.
	    gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    }catch(e) {}
    
    // If we don't have a GL context, give up now
    if (!gl) {
        alert("Unable to initialize WebGL. Your browser may not support it.");
        gl = null;
    }
    
    return gl;
}

function createGLContext(canvas) {
    var names = ["webgl", "experimental-webgl"];
    var context = null;
    for (var i=0; i < names.length; i++) {
        try {
    		context = canvas.getContext(names[i]);
        } catch(e) {}
        if (context) {
      		break;
        }
    }
    if (context) {
        context.viewportWidth = canvas.width;
        context.viewportHeight = canvas.height;
    } else {
    	alert("Failed to create WebGL context!");
    }
    return context;
}

function loadShaderFromDOM(id) {
    var shaderScript = document.getElementById(id);
    
    // If we don't find an element with the specified id
    // we do an early exit 
    if (!shaderScript) {
    	return null;
    }
    
    // Loop through the children for the found DOM element and
    // build up the shader source code as a string
    var shaderSource = "";
    var currentChild = shaderScript.firstChild;
    while (currentChild) {
        if (currentChild.nodeType == 3) { // 3 corresponds to TEXT_NODE
      		shaderSource += currentChild.textContent;
        }
        currentChild = currentChild.nextSibling;
    }
    
    var shader;
    if (shaderScript.type == "x-shader/x-fragment") {
    	shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type == "x-shader/x-vertex") {
    	shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
    	return null;
    }
    
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    	alert(gl.getShaderInfoLog(shader));
    	return null;
    } 
    return shader;
}



function draw(currentTime){
	pwgl.requestId = requestAnimationFrame(draw);

	if (currentTime === 'undefined'){
		currentTime = Date.now();
	}
// 	console.log(currentTime);
// console.log(pwgl.previousFrameTimeStamp);
// 	console.log(currentTime - pwgl.previousFrameTimeStamp);
	// Update FPS if a second or more has passed since last update
	if ((currentTime - pwgl.previousFrameTimeStamp) >= 1000){
		console.log("b");
		pwgl.fpsCounter.innerHTML = pwgl.nbrOfFrameForFPS;
		pwgl.nbrOfFrameForFPS = 0;
		pwgl.previousFrameTimeStamp = currentTime;
	}
	
	
	
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	
	mat4.ortho(-1, 1, -1, 1, -1.1, 100, projectionMatrix);
	
// 	mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 
// 	                 0.1, 100.0, projectionMatrix);
	mat4.identity(modelViewMatrix);
// 	mat4.lookAt([0, 0, -5],[0, 0, 0], [0, 1,0], modelViewMatrix);

	uploadModelViewMatrixToShader();
	uploadProjectionMatrixToShader();
	
	// Disable vertex attrib array and use constant color for the cube.
    gl.disableVertexAttribArray(shaderProgram.vertexColorAttribute);
    // Set color
    gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, 0.0, 0.0, 1.0, 1.0);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 
                         vertexPositionBuffer.itemSize, 
                         gl.FLOAT, false, 0, 0);
        
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
        
    gl.drawElements(gl.TRIANGLES, vertexIndexBuffer.numberOfItems, 
                  gl.UNSIGNED_SHORT, 0);
    
    pwgl.nbrOfFrameForFPS++;
}

function uploadModelViewMatrixToShader() {
	gl.uniformMatrix4fv(shaderProgram.uniformMVMatrix, false, modelViewMatrix);
}

function uploadProjectionMatrixToShader() {
	gl.uniformMatrix4fv(shaderProgram.uniformProjMatrix, false, projectionMatrix);
}
	
function containsObject(list, obj) {
    var i;
    for (i = 0; i < list.length; i=i+3) {
        if ( list[i] === obj.x && list[i+1] === obj.y && list[i+2] === obj.z) {
            return i;
        }
    }
    return -1;
}

function setupBuffers(){
	vertexPositionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
	var vertexPosition = new Array();
	var facesVec3Array;

	for (i=0; i < maxNPix; i++){
		facesVec3Array = new Array();
		facesVec3Array = healpix.getBoundaries(i);
		
		vertexPosition.push(facesVec3Array[0].x);
		vertexPosition.push(facesVec3Array[0].y);
		vertexPosition.push(facesVec3Array[0].z);
		
		vertexPosition.push(facesVec3Array[1].x);
		vertexPosition.push(facesVec3Array[1].y);
		vertexPosition.push(facesVec3Array[1].z);
		
		vertexPosition.push(facesVec3Array[2].x);
		vertexPosition.push(facesVec3Array[2].y);
		vertexPosition.push(facesVec3Array[2].z);
		
		vertexPosition.push(facesVec3Array[3].x);
		vertexPosition.push(facesVec3Array[3].y);
		vertexPosition.push(facesVec3Array[3].z);
		
	}
	
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPosition), gl.STATIC_DRAW);
	vertexPositionBuffer.itemSize = 3;
	vertexPositionBuffer.numberOfItems = vertexPosition.length; 
	
    
    vertexIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
    var vertexIndices = new Array();;
    var baseFaceIndex = 0; 
    for (j=0; j< vertexPosition.length; j=j+12){
    	vertexIndices.push(baseFaceIndex);
    	vertexIndices.push(baseFaceIndex+1);
    	vertexIndices.push(baseFaceIndex+2);
    	
    	vertexIndices.push(baseFaceIndex);
    	vertexIndices.push(baseFaceIndex+2);
    	vertexIndices.push(baseFaceIndex+3);
    	
    	baseFaceIndex = baseFaceIndex+4;
    }
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndices), gl.STATIC_DRAW);
    vertexIndexBuffer.itemSize = 1;
    vertexIndexBuffer.numberOfItems = vertexIndices.length;

	
    console.log(vertexPosition);
	console.log(vertexIndices);

	console.log(vertexPosition.length);
	console.log(vertexIndices.length);
	
	console.log(vertexPositionBuffer);
	console.log(vertexIndexBuffer);
	
	
}

function setupShaders() {
	  var vertexShader = loadShaderFromDOM("shader-vs");
	  var fragmentShader = loadShaderFromDOM("shader-fs");
	  
	  shaderProgram = gl.createProgram();
	  gl.attachShader(shaderProgram, vertexShader);
	  gl.attachShader(shaderProgram, fragmentShader);
	  gl.linkProgram(shaderProgram);

	  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
	    alert("Failed to setup shaders");
	  }

	  gl.useProgram(shaderProgram);
	  
	  shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition"); 
	  shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
	  shaderProgram.uniformMVMatrix = gl.getUniformLocation(shaderProgram, "uMVMatrix");
	  shaderProgram.uniformProjMatrix = gl.getUniformLocation(shaderProgram, "uPMatrix");

	  gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

	  modelViewMatrix = mat4.create(); 
	  projectionMatrix = mat4.create();
	  modelViewMatrixStack = new Array();;
}

function setupTextures(){
	console.log("setupTextures() not yet implemented");
}

function handleContextLost(event){
	event.preventDefault();
	cancelRequestAnimFrame(pwgl.requestId);
}

function handleContextRestored(event){
	setupShaders(); 
	  setupBuffers();
	  setupTextures();
	  gl.clearColor(1.0, 1.0, 1.0, 1.0);
	  pwgl.requestId = requestAnimationFrame(draw, canvas);
}


function startup() {
	canvas = document.getElementById("myGLCanvas");
	canvas.addEventListener('webglcontextlost', handleContextLost, false);
	canvas.addEventListener('webglcontextrestored', handleContextRestored, false);
	
	gl = WebGLDebugUtils.makeDebugContext(createGLContext(canvas));
	setupShaders(); 
	setupBuffers();
	setupTextures();
	gl.clearColor(1.0, 1.0, 1.0, 1.0);
	gl.enable(gl.DEPTH_TEST);
	
	pwgl.nbrOfFrameForFPS = 0;
	pwgl.previousFrameTimeStamp = Date.now();
	pwgl.fpsCounter = document.getElementById("fps");
	
	var coordsDiv = document.getElementById('coords');
canvas.onmousedown = function(ev) {   // Mouse is pressed
	    
	    var vx = ev.clientX; // x coordinate of a mouse pointer
	    var vy = ev.clientY; // y coordinate of a mouse pointer
	    var rect = ev.target.getBoundingClientRect() ;

	    var xy = viewToWorld(vx, vy, rect);
	    console.log("canvas coords:");
	    console.log(xy);
	    var xyz = worldToModel(xy);
	    console.log("WebGL coords:");
	    console.log(xyz);
	    
	    var radec = modelToRaDec(xyz);
	    console.log("ra dec coords:");
	    console.log(radec);
	    console.log("------------------------");
	}
	
	canvas.onmousemove = function(ev) {   // Mouse is pressed
	    
	    var vx = ev.clientX; // x coordinate of a mouse pointer
	    var vy = ev.clientY; // y coordinate of a mouse pointer
	    var rect = ev.target.getBoundingClientRect() ;
	
	    vxy = [vx, vy];
	    
	    console.log("view coords:");
	    console.log(vxy);
	    var xy = viewToWorld(vx, vy, rect);
	    console.log("canvas coords:");
	    console.log(xy);
	    var xyz = worldToModel(xy);
	    console.log("WebGL coords:");
	    console.log(xyz);
	    
	    var radec = modelToRaDec(xyz);
	    console.log("ra dec coords:");
	    console.log(radec);
	    console.log("------------------------");
	    
	    coordsDiv.innerHTML = "ra: "+radec[0]+" dec: "+radec[1];
	}
	
	draw();
}

function viewToWorld(vx, vy, rect){
	var x = ((vx - rect.left) - canvas.width/2)/(canvas.width/2);
    var y = (canvas.height/2 - (vy - rect.top))/(canvas.height/2);
    return [x, y];
}

function worldToModel(xy){
// 	var z = Math.sqrt(1 - xy[0]*xy[0] - xy[1]*xy[1]);
// 	return [xy[0], xy[1], z];
	var x = Math.sqrt(1 - xy[0]*xy[0] - xy[1]*xy[1]);
	var y = xy[0];
	var z = xy[1];
	return [x, y, z];
}

function modelToRaDec(xyz){
	var ra, dec;
	ra = Math.atan2(xyz[1], xyz[0]);
	if (ra < 0){
		ra += 2*Math.PI;
	}
	if (ra >= 2*Math.PI){
		ra -= 2*Math.PI;
	}
	dec = Math.atan2(Math.sqrt(xyz[0]*xyz[0] + xyz[1]*xyz[1]), xyz[2]);

	return [ra* 180 / Math.PI, dec* 180 / Math.PI];
}
</script>
</head>

<body onload="startup();">
	<div style="border: 1px solid black; margin: 40px; position: absolute;" >
  		<canvas id="myGLCanvas" width="500" height="500"></canvas>
  	</div>
  	<div id="fps-counter">
  		FPS: <span id="fps">--</span>
  	</div>
  	<div id="coords">
  		coords: <span id="coords">--</span>
  	</div>
</body>
</html>

