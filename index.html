<!DOCTYPE HTML> 
<html>
<head>
<meta charset="UTF-8">

<title>Insert title here</title>
<script src="lib/Healpix/Xyf.js"></script>
<script src="lib/Healpix/Vec3.js"></script>
<script src="lib/Healpix/Hploc.js"></script>
<script src="lib/Healpix/Fxyf.js"></script>
<script src="lib/Healpix/Healpix.js"></script> 

<script src="lib/utils/webgl-debug.js"></script>

<script src="lib/glMatrix/glMatrix.js"></script>

<script id="shader-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoordinates;

	//attribute vec4 aVertexColor;
  
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
  
	//varying vec4 vColor;
  	varying vec2 vTextureCoordinates;

	void main() {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		//vColor = aVertexColor;
		vTextureCoordinates = aTextureCoordinates;
	}
</script>

<script id="shader-fs" type="x-shader/x-fragment">
  	precision mediump float;
  
	varying vec2 vTextureCoordinates;
	uniform sampler2D uSampler;

  	//varying vec4 vColor;
  	void main() {
    	//gl_FragColor = vColor;
		gl_FragColor = texture2D(uSampler, vTextureCoordinates); 
  	} 
</script>

<script type="text/javascript">

var norder = 3;
var nside = Math.pow(2, norder);
var healpix = new Healpix(nside);
var maxNPix = healpix.getNPix();

console.log("maxNPix: "+maxNPix);

var gl;
var canvas;

var pwgl = {};
pwgl.ongoingImageLoads = [];

function initWebGL(canvas) {
    gl = null;
    
    try {
        // Try to grab the standard context. If it fails, fallback to experimental.
	    gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    }catch(e) {}
    
    // If we don't have a GL context, give up now
    if (!gl) {
        alert("Unable to initialize WebGL. Your browser may not support it.");
        gl = null;
    }
    
    return gl;
}

function createGLContext(canvas) {
    var names = ["webgl", "experimental-webgl"];
    var context = null;
    for (var i=0; i < names.length; i++) {
        try {
    		context = canvas.getContext(names[i]);
        } catch(e) {}
        if (context) {
      		break;
        }
    }
    if (context) {
        context.viewportWidth = canvas.width;
        context.viewportHeight = canvas.height;
    } else {
    	alert("Failed to create WebGL context!");
    }
    return context;
}

function loadShaderFromDOM(id) {
    var shaderScript = document.getElementById(id);
    
    // If we don't find an element with the specified id
    // we do an early exit 
    if (!shaderScript) {
    	return null;
    }
    
    // Loop through the children for the found DOM element and
    // build up the shader source code as a string
    var shaderSource = "";
    var currentChild = shaderScript.firstChild;
    while (currentChild) {
        if (currentChild.nodeType == 3) { // 3 corresponds to TEXT_NODE
      		shaderSource += currentChild.textContent;
        }
        currentChild = currentChild.nextSibling;
    }
    
    var shader;
    if (shaderScript.type == "x-shader/x-fragment") {
    	shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type == "x-shader/x-vertex") {
    	shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
    	return null;
    }
    
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    	alert(gl.getShaderInfoLog(shader));
    	return null;
    } 
    return shader;
}



function draw(){
	pwgl.requestId = requestAnimationFrame(draw);
	
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	
	mat4.ortho(-1, 1, -1, 1, -1.1, 100, pwgl.projectionMatrix);
	
// 	mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 
// 	                 0.1, 100.0, projectionMatrix);
	mat4.identity(pwgl.modelViewMatrix);
// 	mat4.lookAt([0, 0, -5],[0, 0, 0], [0, 1,0], modelViewMatrix);

	uploadModelViewMatrixToShader();
	uploadProjectionMatrixToShader();
	gl.uniform1i(pwgl.uniformSamplerLoc, 0);
	
	// Disable vertex attrib array and use constant color for the cube.
//     gl.disableVertexAttribArray(shaderProgram.vertexColorAttribute);
    // Set color
//     gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, 0.0, 0.0, 1.0, 1.0);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.vertexPositionBuffer);
    gl.vertexAttribPointer(pwgl.vertexPositionAttributeLoc,
    					pwgl.VERTEX_POS_BUF_ITEM_SIZE, 
                       	gl.FLOAT, false, 0, 0);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.vertexTextureCoordinateBuffer);
    gl.vertexAttribPointer(pwgl.vertexTextureAttributeLoc,
    					pwgl.VERTEX_TEX_COORD_BUF_ITEM_SIZE, 
                       	gl.FLOAT, false, 0, 0);
    gl.activeTexture(gl.TEXTURE0);
    for (var i=0;i<maxNPix;i++){
    	gl.bindTexture(gl.TEXTURE_2D, pwgl.texturesArray[i]);	
    }    
    
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.vertexIndexBuffer);
        
    gl.drawElements(gl.TRIANGLES, pwgl.VERTEX_INDEX_BUF_NUM_ITEMS, 
                  gl.UNSIGNED_SHORT, 0);
    
}

function uploadModelViewMatrixToShader() {
	gl.uniformMatrix4fv(pwgl.uniformMVMatrixLoc, false, pwgl.modelViewMatrix);
}

function uploadProjectionMatrixToShader() {
	gl.uniformMatrix4fv(pwgl.uniformProjMatrixLoc, false, pwgl.projectionMatrix);
}

function setupBuffers(){
	pwgl.vertexPositionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.vertexPositionBuffer);
	var vertexPosition = new Float32Array(12*maxNPix);
	var facesVec3Array;

	for (var i=0; i < maxNPix; i++){
		facesVec3Array = new Array();
		facesVec3Array = healpix.getBoundaries(i);

		vertexPosition[12*i] = facesVec3Array[0].x ;
		vertexPosition[12*i+1] = facesVec3Array[0].y;
		vertexPosition[12*i+2] = facesVec3Array[0].z;
		
		vertexPosition[12*i+3] = facesVec3Array[1].x;
		vertexPosition[12*i+4] = facesVec3Array[1].y;
		vertexPosition[12*i+5] = facesVec3Array[1].z;
		
		vertexPosition[12*i+6] = facesVec3Array[2].x;
		vertexPosition[12*i+7] = facesVec3Array[2].y;
		vertexPosition[12*i+8] = facesVec3Array[2].z;
		
		vertexPosition[12*i+9] = facesVec3Array[3].x;
		vertexPosition[12*i+10] = facesVec3Array[3].y;
		vertexPosition[12*i+11] = facesVec3Array[3].z;
	
	}
	gl.bufferData(gl.ARRAY_BUFFER, vertexPosition, gl.STATIC_DRAW);
	pwgl.VERTEX_POS_BUF_ITEM_SIZE = 3;
	pwgl.VERTEX_POS_BUF_NUM_ITEMS = vertexPosition.length; 
	
	
    pwgl.vertexTextureCoordinateBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.vertexTextureCoordinateBuffer);
    var textureCoordinates = new Float32Array(8*maxNPix);
    for (var i=0; i < maxNPix; i++){
    	// [1, 0],[1, 1],[0, 1],[0, 0]
    	textureCoordinates[8*i] = 1.0;
    	textureCoordinates[8*i+1] = 0.0;
    	textureCoordinates[8*i+2] = 1.0;
    	textureCoordinates[8*i+3] = 1.0;
    	textureCoordinates[8*i+4] = 0.0;
    	textureCoordinates[8*i+5] = 1.0;
    	textureCoordinates[8*i+6] = 0.0;
    	textureCoordinates[8*i+7] = 0.0;
    }
    gl.bufferData(gl.ARRAY_BUFFER, textureCoordinates, gl.STATIC_DRAW);
    pwgl.VERTEX_TEX_COORD_BUF_ITEM_SIZE = 2;
    pwgl.VERTEX_TEX_COORD_BUF_NUM_ITEMS = textureCoordinates.length;
    
	
	pwgl.vertexIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.vertexIndexBuffer);
    var vertexIndices = new Uint16Array(6*maxNPix);
    var baseFaceIndex = 0; 
    for (var j=0; j< maxNPix; j++){
    	vertexIndices[6*j] = baseFaceIndex;
    	vertexIndices[6*j+1] = baseFaceIndex + 1;
    	vertexIndices[6*j+2] = baseFaceIndex + 2;
    	
    	vertexIndices[6*j+3] = baseFaceIndex;
    	vertexIndices[6*j+4] = baseFaceIndex + 2;
    	vertexIndices[6*j+5] = baseFaceIndex + 3;
    	
    	baseFaceIndex = baseFaceIndex+4;
    }
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, vertexIndices, gl.STATIC_DRAW);
    pwgl.VERTEX_INDEX_BUF_ITEM_SIZE = 1;
    pwgl.VERTEX_INDEX_BUF_NUM_ITEMS = vertexIndices.length;

	
    console.log(textureCoordinates);
    console.log(vertexPosition);
    console.log(vertexIndices);
    
	
    console.log(textureCoordinates.length);
	console.log(vertexPosition.length);
	console.log(vertexIndices.length);
	
}

function setupTextures(){
	pwgl.texturesArray = [];
	for (var i=0; i<maxNPix;i++){
		pwgl.texturesArray[i] = gl.createTexture();
		loadImageForTexture(i, pwgl.texturesArray[i]);
	}
}

function loadImageForTexture(i, texture){
	var image = new Image();
	image.onload = function(){
		pwgl.ongoingImageLoads.splice(pwgl.ongoingImageLoads.indexOf(image), 1);
		textureFinishedLoading(image, texture);
	}
	pwgl.ongoingImageLoads.push(image);
	image.crossOrigin = "anonymous";
	image.src="http://skies.esac.esa.int/DSSColor/Norder3/Dir0/Npix"+i+".jpg";
}

function textureFinishedLoading(image, texture){
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
	
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
	
	gl.generateMipmap(gl.TEXTURE_2D);
	
// 	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	
// 	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
// 	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
	
// 	gl.bindTexture(gl.TEXTURE_2D, null);
}

function setupShaders() {
	  var vertexShader = loadShaderFromDOM("shader-vs");
	  var fragmentShader = loadShaderFromDOM("shader-fs");
	  
	  var shaderProgram = gl.createProgram();
	  gl.attachShader(shaderProgram, vertexShader);
	  gl.attachShader(shaderProgram, fragmentShader);
	  gl.linkProgram(shaderProgram);

	  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS) && !gl.isContextLost()) {
	    alert("Failed to setup shaders");
	  }

	  gl.useProgram(shaderProgram);
	  
	  pwgl.vertexPositionAttributeLoc = gl.getAttribLocation(shaderProgram, "aVertexPosition"); 
	  pwgl.vertexTextureAttributeLoc = gl.getAttribLocation(shaderProgram, "aTextureCoordinates");
	  pwgl.uniformMVMatrixLoc = gl.getUniformLocation(shaderProgram, "uMVMatrix");
	  pwgl.uniformProjMatrixLoc = gl.getUniformLocation(shaderProgram, "uPMatrix");
	  pwgl.uniformSamplerLoc = gl.getUniformLocation(shaderProgram, "uPMatrix");

	  gl.enableVertexAttribArray(pwgl.vertexPositionAttributeLoc);
	  gl.enableVertexAttribArray(pwgl.vertexTextureAttributeLoc);

	  pwgl.modelViewMatrix = mat4.create(); 
	  pwgl.projectionMatrix = mat4.create();
	  pwgl.modelViewMatrixStack = [];
}



function handleContextLost(event){
	event.preventDefault();
	cancelRequestAnimFrame(pwgl.requestId);
	
	// Ignore all ongoing image load by removing
	// their onload handler
	for (var i=0; i < pwgl.ongoingImageLoads.length; i++){
		pwgl.ongoingImageLoads[i] = undefined;
	}
	pwgl.ongoingImageLoads = [];
}

function handleContextRestored(event){
	setupShaders(); 
	setupBuffers();
	setupTextures();
// 	gl.clearColor(0.0, 0.0, 0.0, 1.0);
	gl.clearColor(1.0, 1.0, 1.0, 1.0);
	gl.enable(gl.DEPTH_TEST);
	pwgl.requestId = requestAnimationFrame(draw, canvas);
}


function startup() {
	canvas = document.getElementById("myGLCanvas");
	
	canvas.addEventListener('webglcontextlost', handleContextLost, false);
	canvas.addEventListener('webglcontextrestored', handleContextRestored, false);
	
	gl = createGLContext(canvas);
	setupShaders(); 
	setupBuffers();
	setupTextures();
// 	gl.clearColor(0.0, 0.0, 0.0, 1.0);
	gl.clearColor(1.0, 1.0, 1.0, 1.0);
	gl.enable(gl.DEPTH_TEST);
	
	var coordsDiv = document.getElementById('coords');
	canvas.onmousedown = function(ev) {   // Mouse is pressed
	    
	    var vx = ev.clientX; // x coordinate of a mouse pointer
	    var vy = ev.clientY; // y coordinate of a mouse pointer
	    var rect = ev.target.getBoundingClientRect() ;

	    var xy = viewToWorld(vx, vy, rect);
	    console.log("canvas coords:");
	    console.log(xy);
	    var xyz = worldToModel(xy);
	    console.log("WebGL coords:");
	    console.log(xyz);
	    
	    var radec = modelToRaDec(xyz);
	    console.log("ra dec coords:");
	    console.log(radec);
	    console.log("------------------------");
	}
	
	canvas.onmousemove = function(ev) {   // Mouse is pressed
	    
	    var vx = ev.clientX; // x coordinate of a mouse pointer
	    var vy = ev.clientY; // y coordinate of a mouse pointer
	    var rect = ev.target.getBoundingClientRect() ;
	
	    vxy = [vx, vy];
	    
	    console.log("view coords:");
	    console.log(vxy);
	    var xy = viewToWorld(vx, vy, rect);
	    console.log("canvas coords:");
	    console.log(xy);
	    var xyz = worldToModel(xy);
	    console.log("WebGL coords:");
	    console.log(xyz);
	    
	    var radec = modelToRaDec(xyz);
	    console.log("ra dec coords:");
	    console.log(radec);
	    console.log("------------------------");
	    
	    coordsDiv.innerHTML = "ra: "+radec[0]+" dec: "+radec[1];
	}
	
	draw();
}

function viewToWorld(vx, vy, rect){
	var x = ((vx - rect.left) - canvas.width/2)/(canvas.width/2);
    var y = (canvas.height/2 - (vy - rect.top))/(canvas.height/2);
    return [x, y];
}

function worldToModel(xy){
	var x = Math.sqrt(1 - xy[0]*xy[0] - xy[1]*xy[1]);
	var y = xy[0];
	var z = xy[1];
	return [x, y, z];
}

function modelToRaDec(xyz){
	var ra, dec;
	ra = Math.atan2(xyz[1], xyz[0]);
	if (ra < 0){
		ra += 2*Math.PI;
	}
	if (ra >= 2*Math.PI){
		ra -= 2*Math.PI;
	}
	dec = Math.atan2(Math.sqrt(xyz[0]*xyz[0] + xyz[1]*xyz[1]), xyz[2]);

	return [ra* 180 / Math.PI, dec* 180 / Math.PI];
}
</script>
</head>

<body onload="startup();">
	<div style="border: 1px solid black; margin: 40px; position: absolute;" >
  		<canvas id="myGLCanvas" width="500" height="500"></canvas>
  	</div>
  	<div id="fps-counter">
  		FPS: <span id="fps">--</span>
  	</div>
  	<div id="coords">
  		coords: <span id="coords">--</span>
  	</div>
</body>
</html>

